"""
Agent Thinking State Management

Provides structured output for agents to emit thinking updates
and track the agent execution flow with real-time status updates.
"""

from dataclasses import dataclass, asdict, field
from typing import Optional, List, Dict, Any
from enum import Enum
import json
from datetime import datetime


class ThinkingStatus(Enum):
    """Status types for agent thinking phases."""
    ANALYZING = "analyzing"
    PROCESSING = "processing"
    RETRIEVING = "retrieving"
    GENERATING = "generating"
    REASONING = "reasoning"
    COMPLETE = "complete"
    ERROR = "error"


# Track last generated status to avoid repetition
_last_generated_status = None


def generate_dynamic_status(context: str, force_new: bool = False) -> str:
    """
    Generate a dynamic thinking status message based on context.
    This function uses the thinking status generator chain.
    
    Args:
        context: Description of what the agent is doing
        force_new: Force generation even if last status is similar
        
    Returns:
        A dynamic status sentence generated by the LLM
    """
    global _last_generated_status
    
    try:
        # Import here to avoid circular imports
        from src.ai_search.chains import thinking_status_generator
        
        # Retry up to 2 times if we get the same status as before
        for attempt in range(2):
            status = thinking_status_generator.invoke({"context": context})
            status = status.strip()
            
            # If it's the same as last time and not forced, try again
            if status == _last_generated_status and not force_new and attempt == 0:
                continue
            
            _last_generated_status = status
            return status
        
        # If all attempts return the same thing, still return it
        return status
        
    except Exception as e:
        # Fallback to context if generation fails
        return context



@dataclass
class ThinkingUpdate:
    """Structured update from an agent about its current thinking process."""
    
    agent_name: str
    """The name of the agent emitting the update."""
    
    status: ThinkingStatus
    """Current status of the agent."""
    
    phase_title: str
    """Human-readable title describing what the agent is doing."""
    
    details: str = ""
    """Additional details about the current phase."""
    
    progress: float = 0.0
    """Progress percentage (0.0 - 1.0)."""
    
    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional metadata specific to this phase."""
    
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    """Timestamp when this update was created."""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        data = asdict(self)
        data["status"] = self.status.value
        return data
    
    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict())


@dataclass
class ThinkingSession:
    """Tracks a complete thinking session with multiple updates from different agents."""
    
    query: str
    """The original user query."""
    
    updates: List[ThinkingUpdate] = field(default_factory=list)
    """All thinking updates in order."""
    
    active_agent: Optional[str] = None
    """Current active agent."""
    
    timestamp_start: str = field(default_factory=lambda: datetime.now().isoformat())
    """Session start timestamp."""
    
    timestamp_end: Optional[str] = None
    """Session end timestamp (if completed)."""
    
    def add_update(self, update: ThinkingUpdate) -> None:
        """Add a thinking update to the session."""
        self.updates.append(update)
        self.active_agent = update.agent_name
    
    def complete(self) -> None:
        """Mark session as completed."""
        self.timestamp_end = datetime.now().isoformat()
        self.active_agent = None
    
    def get_agent_updates(self, agent_name: str) -> List[ThinkingUpdate]:
        """Get all updates from a specific agent."""
        return [u for u in self.updates if u.agent_name == agent_name]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "query": self.query,
            "updates": [u.to_dict() for u in self.updates],
            "active_agent": self.active_agent,
            "timestamp_start": self.timestamp_start,
            "timestamp_end": self.timestamp_end,
        }


class ThinkingEmitter:
    """
    Helper class to emit thinking updates during agent processing.
    
    Usage:
        emitter = ThinkingEmitter("QueryAnalyzer")
        emitter.emit_analyzing("Analyzing query clarity...")
        emitter.emit_processing("Processing natural language...")
    """
    
    def __init__(self, agent_name: str):
        self.agent_name = agent_name
    
    def emit_dynamic(
        self,
        status: ThinkingStatus,
        context: str,
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """
        Emit a thinking update with dynamically generated status message.
        
        Args:
            status: Status type (ANALYZING, PROCESSING, etc.)
            context: Context describing what's happening
            details: Additional details
            progress: Progress percentage (0.0 - 1.0)
            metadata: Additional metadata
            
        Returns:
            ThinkingUpdate with dynamically generated phase_title
        """
        phase_title = generate_dynamic_status(context)
        return self.emit(status, phase_title, details, progress, metadata)
    
    def emit(
        self,
        status: ThinkingStatus,
        phase_title: str,
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit a thinking update."""
        return ThinkingUpdate(
            agent_name=self.agent_name,
            status=status,
            phase_title=phase_title,
            details=details,
            progress=progress,
            metadata=metadata or {},
        )
    
    def emit_analyzing(
        self, 
        phase_title: str, 
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit an analyzing status update."""
        return self.emit(ThinkingStatus.ANALYZING, phase_title, details, progress, metadata)
    
    def emit_processing(
        self, 
        phase_title: str, 
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit a processing status update."""
        return self.emit(ThinkingStatus.PROCESSING, phase_title, details, progress, metadata)
    
    def emit_retrieving(
        self, 
        phase_title: str, 
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit a retrieving status update."""
        return self.emit(ThinkingStatus.RETRIEVING, phase_title, details, progress, metadata)
    
    def emit_generating(
        self, 
        phase_title: str, 
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit a generating status update."""
        return self.emit(ThinkingStatus.GENERATING, phase_title, details, progress, metadata)
    
    def emit_reasoning(
        self, 
        phase_title: str, 
        details: str = "",
        progress: float = 0.0,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit a reasoning status update."""
        return self.emit(ThinkingStatus.REASONING, phase_title, details, progress, metadata)
    
    def emit_complete(
        self, 
        phase_title: str = "Complete",
        details: str = "",
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit a complete status update."""
        return self.emit(ThinkingStatus.COMPLETE, phase_title, details, 1.0, metadata)
    
    def emit_error(
        self, 
        phase_title: str,
        details: str = "",
        metadata: Optional[Dict[str, Any]] = None,
    ) -> ThinkingUpdate:
        """Emit an error status update."""
        return self.emit(ThinkingStatus.ERROR, phase_title, details, 0.0, metadata)
